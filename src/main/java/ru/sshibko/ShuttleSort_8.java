package ru.sshibko;

public class ShuttleSort_8 {

    public static void shuttleSort(int[] arr) {
        boolean swapped = true;
        int start = 0;
        int end = arr.length - 1;

        while (swapped) {
            swapped = false;

            for (int i = start; i < end; i++) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    swapped = true;
                }
            }

            if (!swapped) {
                break;
            }

            swapped = false;

            for (int i = end - 1; i >= start; i--) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    swapped = true;
                }
            }
            start++;
            end--;
        }
    }

/**    Проходим по массиву с начала до конца, и при нахождении элемента, который меньше предыдущего элемента, меняем
    их местами.
    Затем проходим от конца массива к началу и при нахождении элемента, который больше предыдущего элемента, меняем
    их местами.
    Это повторяется до тех пор, пока массив не будет полностью отсортирован.*/

/** Одним из способов улучшения алгоритма является оптимизация его производительности. Например, можно использовать
 *  более эффективный алгоритм сортировки, такой как быстрая сортировка (quicksort) или сортировка слиянием (merge sort).

    Также можно оптимизировать алгоритм путем добавления дополнительных проверок на каждой итерации, чтобы избежать
    лишних перестановок, если массив уже отсортирован.

    Использование параллельного программирования может ускорить работу алгоритма на многопроцессорных системах.*/
}
